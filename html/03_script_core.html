    // --- Core Logic ---
    function analyzeCode() {
        const text = inputEl.value;
        scriptLines = text.split(/\r?\n/);
        definedLabels.clear();
        definedVars.clear();
        let errorCount = 0;

        // Pass 1: Definitions
        scriptLines.forEach((line, i) => {
            const t = line.trim();
            if (!t || t.startsWith('#') || t.toUpperCase().startsWith('REM')) return;
            if (t.toUpperCase().startsWith('LABEL')) {
                const p = t.split(/\s+/);
                if (p[1]) definedLabels.set(p[1], i + 1);
            }
            if (t.toUpperCase().startsWith('SET')) {
                const eq = t.indexOf('=');
                if (eq > 3) {
                    const v = t.substring(3, eq).trim();
                    const vName = v.split(/\s+/)[0];
                    if (!definedVars.has(vName)) definedVars.set(vName, i + 1);
                }
            }
        });

        updateStructureTab();

        // Pass 2: Rendering
        let html = "";
        let globalCharIndex = 0;

        scriptLines.forEach((line, i) => {
            const safeLine = escapeHtml(line);
            let lineHtml = safeLine;
            let bgClass = "";
            let msgHtml = "";

            const trim = line.trim();
            if (trim.length > 0 && !trim.startsWith('#') && !trim.toUpperCase().startsWith('REM')) {
                const sp = trim.indexOf(' ');
                const cmdRaw = (sp === -1 ? trim : trim.substring(0, sp)).toUpperCase();
                const paren = cmdRaw.indexOf('(');
                const cmdPure = (paren !== -1 ? cmdRaw.substring(0, paren) : cmdRaw);

                if (COMMANDS.some(c => c.toUpperCase() === cmdPure)) {
                    const res = renderLine(line, cmdPure, globalCharIndex);
                    lineHtml = res.html;
                    if (res.error) {
                        bgClass = "error-bg";
                        msgHtml = `<span class="msg-text err-text">${res.error}</span>`;
                        errorCount++;
                    } else if (res.warning) {
                        bgClass = "warning-bg";
                        msgHtml = `<span class="msg-text warn-text">${res.warning}</span>`;
                    }
                } else {
                    lineHtml = `<span class="other">${safeLine}</span>`;
                }
            } else {
                if (trim.length > 0) lineHtml = `<span class="other">${safeLine}</span>`;
            }

            html += `<div class="line ${bgClass}">${lineHtml}${msgHtml}</div>`;
            // +1 for newline char
            globalCharIndex += line.length + 1;
        });
        
        if (text.endsWith('\n')) html += `<div class="line"><br></div>`;
        
        highlightEl.innerHTML = html;
        const st = document.getElementById('status-area');
        st.textContent = errorCount === 0 ? "OK: エラーはありません" : `エラー: ${errorCount} 件`;
        st.style.color = errorCount === 0 ? "green" : "red";
    }

    // Render a single line with syntax coloring & paren match check
    function renderLine(line, cmdPure, lineStartIndex) {
        let html = "";
        let error = null;
        let warning = null;
        
        // Helper to check if a char at relative index 'relIdx' is matched
        const isMatched = (relIdx) => matchedParenIndices.has(lineStartIndex + relIdx);

        const match = line.match(new RegExp(`^(\\s*)(${cmdPure})`, "i"));
        if (!match) return { html: escapeHtml(line) };

        const indent = escapeHtml(match[1]);
        const cmdStr = escapeHtml(match[2]);
        const restRaw = line.substring(match[0].length);
        const restStartIdx = match[0].length; // relative to line

        if (restRaw.startsWith('(')) {
            html += `<span class="other">${indent}</span><span class="func">${cmdStr}</span>`;
            
            const endP = restRaw.lastIndexOf(')');
            if (endP !== -1) {
                // '('
                const openIdx = restStartIdx; 
                const openClass = isMatched(openIdx) ? "func paren-match" : "func";
                html += `<span class="${openClass}">(</span>`;
                
                const args = restRaw.substring(1, endP);
                html += colorizeArgs(args, lineStartIndex + restStartIdx + 1); // +1 for '('

                // ')'
                const closeIdx = restStartIdx + endP;
                const closeClass = isMatched(closeIdx) ? "func paren-match" : "func";
                html += `<span class="${closeClass}">)</span>`;
                
                const tail = restRaw.substring(endP + 1);
                if (tail.trim().length > 0) {
                    html += `<span class="other">${escapeHtml(tail)}</span>`;
                    warning = "閉じ括弧の後ろの文字は無視されます";
                } else {
                    html += escapeHtml(tail);
                }
                
                const err = validateExpr(args);
                if (err) error = err;
            } else {
                // Unmatched '('
                const openIdx = restStartIdx;
                const openClass = isMatched(openIdx) ? "func paren-match" : "func";
                html += `<span class="${openClass}">(</span>` + colorizeArgs(restRaw.substring(1), lineStartIndex + restStartIdx + 1);
                error = "閉じ括弧 ) がありません";
            }
        } else {
            html += `<span class="other">${indent}</span><span class="func">${cmdStr}</span>`;
            let args = restRaw;
            let argsGlobalStart = lineStartIndex + restStartIdx;

            if (cmdPure === "SET") {
                const eq = args.indexOf('=');
                if (eq !== -1) {
                    const vPart = args.substring(0, eq);
                    const vMatch = vPart.match(/([a-zA-Z_][a-zA-Z0-9_]*)/);
                    if(vMatch) {
                         const pre = vPart.substring(0, vMatch.index);
                         const post = vPart.substring(vMatch.index + vMatch[0].length);
                         html += `<span class="other">${escapeHtml(pre)}</span><span class="var">${vMatch[0]}</span><span class="other">${escapeHtml(post)}</span>`;
                    } else {
                        html += `<span class="other">${escapeHtml(vPart)}</span>`;
                    }
                    html += `<span class="func">=</span>`;
                    const expr = args.substring(eq + 1);
                    html += colorizeArgs(expr, argsGlobalStart + eq + 1);
                    const err = validateExpr(expr);
                    if (err) error = err;
                } else {
                    html += `<span class="other">${escapeHtml(args)}</span>`;
                    error = "= が必要です";
                }
            } else if (cmdPure === "GOTO" || cmdPure === "GOSUB") {
                const lbl = args.trim();
                html += `<span class="label-ref">${escapeHtml(args)}</span>`;
                if (!definedLabels.has(lbl)) error = "未定義ラベル";
            } else if (cmdPure === "IF") {
                const gt = args.toUpperCase().indexOf("GOTO");
                if (gt !== -1) {
                    const expr = args.substring(0, gt);
                    const lblPart = args.substring(gt + 4);
                    html += colorizeArgs(expr, argsGlobalStart);
                    html += `<span class="func">GOTO</span>`;
                    html += `<span class="label-ref">${escapeHtml(lblPart)}</span>`;
                    
                    const err = validateExpr(expr);
                    if (err) error = err;
                    if (!definedLabels.has(lblPart.trim())) error = (error ? error+" " : "") + "未定義ラベル";
                } else {
                    html += colorizeArgs(args, argsGlobalStart);
                    error = "GOTO が必要です";
                }
            } else if (cmdPure === "LABEL") {
                html += `<span class="label-def">${escapeHtml(args)}</span>`;
            } else {
                html += colorizeArgs(args, argsGlobalStart);
                if (cmdPure === "WAIT") {
                     const err = validateExpr(args);
                     if(err) error = err;
                }
            }
        }
        return { html, error, warning };
    }

    function colorizeArgs(text, startGlobalIndex) {
        let html = "";
        const regex = /([a-zA-Z_][a-zA-Z0-9_]*)|([(),])|([^a-zA-Z_(),]+)/g;
        let match;
        while ((match = regex.exec(text)) !== null) {
            const str = match[0];
            const safe = escapeHtml(str);
            const tokenGlobalIdx = startGlobalIndex + match.index;

            if (match[1]) { 
                const low = str.toLowerCase();
                if (BUILTIN_FUNCS.has(low)) html += `<span class="func">${safe}</span>`;
                else if (definedVars.has(str)) html += `<span class="var">${safe}</span>`;
                else if (VALID_CONSTANTS.has(str.toUpperCase())) html += `<span class="arg">${safe}</span>`;
                else html += `<span class="arg">${safe}</span>`;
            } else if (match[2]) {
                // Parens inside args
                if (str === '(' || str === ')') {
                    const pClass = isMatchedGlobal(tokenGlobalIdx) ? "func paren-match" : "func";
                    html += `<span class="${pClass}">${safe}</span>`;
                } else {
                    html += `<span class="func">${safe}</span>`; // Comma
                }
            } else {
                html += `<span class="arg">${safe}</span>`;
            }
        }
        return html;
    }
    
    function isMatchedGlobal(idx) {
        return matchedParenIndices.has(idx);
    }

    function validateExpr(expr) {
        const noStr = expr.replace(/"[^"]*"/g, "0");
        const tokens = noStr.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
        if (!tokens) return null;
        for (const t of tokens) {
            const low = t.toLowerCase();
            if (BUILTIN_FUNCS.has(low)) continue;
            if (VALID_CONSTANTS.has(t.toUpperCase())) continue;
            if (definedVars.has(t)) continue;
            if (COMMANDS.some(c => c.toUpperCase() === low.toUpperCase())) continue;
            return `未定義: ${t}`;
        }
        return null;
    }

    function escapeHtml(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // --- Parenthesis Matching Logic ---
    function updateParenMatch() {
        const cursor = inputEl.selectionStart;
        const text = inputEl.value;
        matchedParenIndices.clear();

        // Check char before and after cursor
        // Priority: 1. After cursor '(|' -> check '(', 2. Before cursor ')|' -> check ')'
        
        let targetIdx = -1;
        let searchDir = 0; // 1: forward, -1: backward

        if (cursor < text.length && text[cursor] === '(') {
            targetIdx = cursor; searchDir = 1;
        } else if (cursor > 0 && text[cursor-1] === ')') {
            targetIdx = cursor-1; searchDir = -1;
        } else if (cursor < text.length && text[cursor] === ')') { // Case: ')|' but check ')' after cursor
            targetIdx = cursor; searchDir = -1;
        } else if (cursor > 0 && text[cursor-1] === '(') { // Case: '(|' but check '(' before cursor
            targetIdx = cursor-1; searchDir = 1;
        }

        if (targetIdx !== -1) {
            const partner = findPartnerParen(text, targetIdx, searchDir);
            if (partner !== -1) {
                matchedParenIndices.add(targetIdx);
                matchedParenIndices.add(partner);
            }
        }
        
        // Re-render only if set changed (Optimized by simple re-render for now as it's fast)
        analyzeCode(); 
    }

    function findPartnerParen(text, idx, dir) {
        const open = '('; const close = ')';
        const target = text[idx];
        const partner = (target === open) ? close : open;
        
        let depth = 0;
        let i = idx;
        while (i >= 0 && i < text.length) {
            const c = text[i];
            if (c === target) depth++;
            else if (c === partner) depth--;
            
            if (depth === 0) return i;
            i += dir;
        }
        return -1;
    }
